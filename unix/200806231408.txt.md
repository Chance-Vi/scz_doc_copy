13.15 fork()+exec*()的exec*()返回-1时如何通知父进程

http://scz.617.cn/unix/200806231408.txt

Q: Dieken@SMTH 2008-06-06 16:01:52

--------------------------------------------------------------------------
/*
 * fork()+exec*()的框架流程我可以控制
 */
if ( ( pid = fork() ) < 0 )
{
    /*
     * show error message
     */
}
else if ( pid > 0 )
{
    /*
     * 父进程需要知道子进程中exec*()是否返回-1，但不关心被执行的目标程序的
     * 返回码。不能调用wait*()等待子进程，因为这将产生阻塞。不能用信号机制，
     * 因为我只能控制fork()+exec*()的框架流程，不能控制整个父进程(没有源代
     * 码)，安装信号句柄的代码不在我的控制之下，不能随意安装新的信号句柄，
     * 以免产生冲突。
     */
}
else
{
    /*
     * 子进程
     */
    if ( -1 == setsid() )
    {
        exit( 0 );
    }
    if ( -1 == chdir( "/" ) )
    {
        exit( 0 );
    }
    if ( -1 == close( 0 ) )
    {
        exit( 0 );
    }
    if ( -1 == close( 1 ) )
    {
        exit( 0 );
    }
    if ( -1 == close( 2 ) )
    {
        exit( 0 );
    }
    /*
     * exec*()的第一形参我无法控制，假设是任意可执行程序
     */
    if ( -1 == exec*( ... ) )
    {
        /*
         * 如果exec*()成功的话，流程永远不会到达此处。
         */
        exit( 0 );
    }
}
--------------------------------------------------------------------------

A: vonNeumann@SMTH 2008-06-06 16:23:14

一个备选方案:

--------------------------------------------------------------------------
int     fds[2];
pid_t   pid;
char    c;
ssize_t n;

pipe( fds );
if ( 0 == ( pid = fork() )
{
    /*
     * 子进程
     */
    close( fds[0] );
    fcntl( fds[1], F_SETFD, FD_CLOEXEC );
    exec*( ... );
    write( fds[1], "", 1 );
    /*
     * 绕过atexit()机制
     */
    _exit( 127 );
}
/*
 * 父进程
 */
close( fds[1] );
/*
 * 如果exec*()成功，read()应该返回0。参APUE 14.2小节。
 */
n   = read( fds[0], &c, 1 );
close( fds[0] );
/*
 * 如果n非零，意味着exec*()返回-1了。
 */
if ( n )
{
    fprintf( stderr, "Ooops ...\n" );
    waitpid( pid, NULL, 0 );
    return( -1 );
}
return( pid );
--------------------------------------------------------------------------
